#+TITLE: HN Digest 2026-01-12 20:00:00 UT UTC
#+DATE: 2026-01-12T20:00:00Z
#+CURATOR: claude
#+SOURCE: https://hacker-news.firebaseio.com/v0/

* Vibe
Victorian LLMs, JavaScript finally gets dates right, and LLVM maintainers need a hug

* Highlights
- TimeCapsuleLLM: An AI that thinks it's 1875 and honestly might be happier for it
- LLVM's dirty laundry: reviewer burnout, endless churn, and undef nightmares
- Temporal API lands: Date is dead, long live immutable timestamps

* Stories

** TimeCapsuleLLM: LLM trained only on data from 1800-1875 :ml:history:llm:research:
:PROPERTIES:
:ID:       46590280
:URL:      https://github.com/haykgrigo3/TimeCapsuleLLM
:HN_URL:   https://news.ycombinator.com/item?id=46590280
:POINTS:   323
:COMMENTS: 133
:BY:       admp
:END:

*** TLDR
Researchers trained a 300M parameter LLM exclusively on 90GB of 19th century London texts spanning 1800-1875. The goal: create an AI that genuinely embodies Victorian knowledge without modern contamination. The model can reference real historical events and writes in period-appropriate style.

*** Take
Finally, an AI that won't recommend you check Stack Overflow or suggest using React. It'll probably just tell you to invest in railways and avoid the Thames water.

*** Comments

**** dogma1138
:PROPERTIES:
:COMMENT_ID: 46590281
:END:
Would be interesting to train a cutting edge model with a cut off date of say 1900 and then prompt it about QM and relativity with some added context. If the model comes up with anything even remotely correct it would be quite a strong evidence that LLMs are a path to something bigger.

**** dash2
:PROPERTIES:
:COMMENT_ID: 46590282
:END:
I'm a bit sceptical of the historical expertise of someone who thinks that 'Who art Henry' is 19th century language. It's not actually grammatically correct English from any century: 'art' is the second person singular.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
TimeCapsuleLLM：仅用1800-1875年数据训练的大语言模型
***** TLDR
研究人员使用90GB的19世纪伦敦文献(1800-1875年)训练了一个3亿参数的大语言模型。目标是创建一个真正体现维多利亚时代知识、不受现代污染的AI。该模型能引用真实历史事件，并以那个时代的风格写作。
***** Take
终于有个AI不会推荐你去看Stack Overflow或建议用React了。它可能只会告诉你投资铁路，别喝泰晤士河的水。
***** Comments
- 如果用1900年截止的数据训练一个先进模型，然后用量子力学和相对论的背景来提问，会很有趣。如果模型能得出任何接近正确的答案，那将是LLM通向更大目标的有力证据。
- 我对那个认为'Who art Henry'是19世纪语言的人的历史专业知识有些怀疑。'art'是第二人称单数，这在任何世纪都不是正确的英语语法。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
TimeCapsuleLLM：1800-1875年のデータのみで訓練されたLLM
***** TLDR
研究者たちが1800-1875年のロンドンの文献90GBのみを使って3億パラメータのLLMを訓練した。目標は現代の汚染なしにヴィクトリア朝の知識を真に体現するAIを作ること。このモデルは実際の歴史的出来事を参照し、時代にふさわしい文体で書く。
***** Take
ついにStack Overflowを見ろとかReactを使えとか言わないAIが登場。たぶん鉄道に投資しろ、テムズ川の水は飲むなと言うだけだろう。
***** Comments
- 1900年カットオフのモデルを訓練して量子力学や相対論について質問したら面白いだろう。もし少しでも正しい答えが出たら、LLMがより大きな何かへの道だという強力な証拠になる。
- 'Who art Henry'が19世紀の言語だと思っている人の歴史的専門知識には懐疑的だ。'art'は二人称単数形で、これはどの世紀でも文法的に正しい英語ではない。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
TimeCapsuleLLM: 1800-1875년 데이터로만 훈련된 LLM
***** TLDR
연구자들이 1800-1875년 런던 문헌 90GB만으로 3억 파라미터 LLM을 훈련했다. 목표는 현대의 오염 없이 빅토리아 시대 지식을 진정으로 구현하는 AI를 만드는 것. 이 모델은 실제 역사적 사건을 참조하고 시대에 맞는 문체로 글을 쓴다.
***** Take
드디어 Stack Overflow 보라거나 React 쓰라고 추천 안 하는 AI가 나왔다. 아마 철도에 투자하고 템즈강 물은 마시지 말라고만 할 것이다.
***** Comments
- 1900년 컷오프 모델을 훈련해서 양자역학과 상대성 이론에 대해 질문하면 흥미로울 것이다. 모델이 조금이라도 맞는 답을 내면 LLM이 더 큰 무언가로 가는 길이라는 강력한 증거가 될 것이다.
- 'Who art Henry'가 19세기 언어라고 생각하는 사람의 역사적 전문성에 의문이 든다. 'art'는 2인칭 단수이며, 이것은 어떤 세기에서도 문법적으로 맞는 영어가 아니다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
TimeCapsuleLLM: LLM entrenado solo con datos de 1800-1875
***** TLDR
Investigadores entrenaron un LLM de 300M de parámetros exclusivamente con 90GB de textos londinenses del siglo XIX (1800-1875). El objetivo: crear una IA que genuinamente encarne el conocimiento victoriano sin contaminación moderna. El modelo puede referenciar eventos históricos reales y escribe en estilo apropiado de la época.
***** Take
Por fin, una IA que no te recomendará revisar Stack Overflow ni sugerirá usar React. Probablemente solo te dirá que inviertas en ferrocarriles y evites el agua del Támesis.
***** Comments
- Sería interesante entrenar un modelo avanzado con fecha de corte de 1900 y preguntarle sobre mecánica cuántica y relatividad con algo de contexto. Si el modelo produce algo remotamente correcto, sería evidencia fuerte de que los LLM son un camino hacia algo más grande.
- Soy un poco escéptico de la experiencia histórica de alguien que piensa que 'Who art Henry' es lenguaje del siglo XIX. No es gramaticalmente correcto en ningún siglo: 'art' es la segunda persona del singular.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
TimeCapsuleLLM: LLM nur mit Daten von 1800-1875 trainiert
***** TLDR
Forscher trainierten ein 300M-Parameter-LLM ausschließlich mit 90GB Londoner Texten des 19. Jahrhunderts (1800-1875). Das Ziel: eine KI erschaffen, die viktorianisches Wissen authentisch verkörpert, ohne moderne Kontamination. Das Modell kann echte historische Ereignisse referenzieren und schreibt im zeitgenössischen Stil.
***** Take
Endlich eine KI, die nicht Stack Overflow empfiehlt oder React vorschlägt. Sie wird dir wahrscheinlich nur sagen, in Eisenbahnen zu investieren und das Themsewasser zu meiden.
***** Comments
- Es wäre interessant, ein hochmodernes Modell mit Stichtag 1900 zu trainieren und es mit etwas Kontext über Quantenmechanik und Relativität zu befragen. Wenn das Modell etwas auch nur annähernd Korrektes liefert, wäre das ein starker Beweis, dass LLMs ein Weg zu etwas Größerem sind.
- Ich bin etwas skeptisch gegenüber der historischen Expertise von jemandem, der denkt, dass 'Who art Henry' Sprache des 19. Jahrhunderts ist. Es ist in keinem Jahrhundert grammatikalisch korrektes Englisch: 'art' ist die zweite Person Singular.
** LLVM: The bad parts :compilers:llvm:infrastructure:opensource:
:PROPERTIES:
:ID:       46588837
:URL:      https://www.npopov.com/2026/01/11/LLVM-The-bad-parts.html
:HN_URL:   https://news.ycombinator.com/item?id=46588837
:POINTS:   204
:COMMENTS: 37
:BY:       vitaut
:END:

*** TLDR
A candid teardown of LLVM's pain points: not enough reviewers causing poor contributor experience, constant API churn breaking downstream projects, painfully slow build times, flaky CI, undef value nightmares, and incomplete migrations that drag on for years. The author frames these as 'opportunities to improve' rather than fatal flaws.

*** Take
The compilers that compile your compilers are held together by duct tape and the quiet desperation of maintainers who've seen too much. At least they're honest about it now.

*** Comments

**** pizlonator
:PROPERTIES:
:COMMENT_ID: 46588838
:END:
This is a good write up and I agree with pretty much all of it. LLVM IR is actually remarkably stable these days. I was able to rebase Fil-C from llvm 17 to 20 in a single day of work.

**** jcranmer
:PROPERTIES:
:COMMENT_ID: 46588839
:END:
One of the things I especially want to see built out for LLVM is a comprehensive executable test suite that starts not from C but from LLVM IR. There's not a lot of documentation about all of the SelectionDAG stuff.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
LLVM：那些糟糕的部分
***** TLDR
坦诚剖析LLVM的痛点：审查者不足导致贡献者体验差，持续的API变动破坏下游项目，编译时间极长，CI不稳定，undef值的噩梦，以及拖延多年的不完整迁移。作者将这些定性为'改进机会'而非致命缺陷。
***** Take
编译你编译器的编译器是靠胶带和见过太多的维护者们的沉默绝望维持的。至少他们现在坦诚了。
***** Comments
- 这篇文章写得很好，我基本同意所有观点。LLVM IR现在实际上非常稳定。我能在一天内将Fil-C从llvm 17移植到20。
- 我特别希望看到LLVM建立一个从LLVM IR而非C开始的综合可执行测试套件。关于SelectionDAG的文档太少了。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
LLVM：悪い部分
***** TLDR
LLVMの問題点を率直に分析：レビュアー不足によるコントリビューター体験の悪化、下流プロジェクトを壊す絶え間ないAPI変更、極端に遅いビルド時間、不安定なCI、undefの悪夢、何年も続く不完全な移行。著者はこれらを致命的欠陥ではなく「改善の機会」として捉えている。
***** Take
コンパイラをコンパイルするコンパイラは、ダクトテープと、見すぎたメンテナーたちの静かな絶望で支えられている。少なくとも今は正直になった。
***** Comments
- 良い記事で、ほぼすべてに同意する。LLVM IRは実際には今日では非常に安定している。Fil-Cをllvm 17から20にリベースするのに1日で済んだ。
- 特にLLVMに構築してほしいのは、Cではなく LLVM IRから始まる包括的な実行可能テストスイートだ。SelectionDAGについてのドキュメントがあまりない。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
LLVM: 나쁜 부분들
***** TLDR
LLVM의 문제점을 솔직하게 분석: 리뷰어 부족으로 인한 기여자 경험 저하, 다운스트림 프로젝트를 망가뜨리는 지속적인 API 변경, 고통스러울 정도로 긴 빌드 시간, 불안정한 CI, undef 값의 악몽, 수년간 끌리는 불완전한 마이그레이션. 저자는 이를 치명적 결함이 아닌 '개선 기회'로 프레이밍한다.
***** Take
당신의 컴파일러를 컴파일하는 컴파일러는 덕트 테이프와 너무 많이 본 메인테이너들의 조용한 절망으로 유지된다. 적어도 이제는 솔직해졌다.
***** Comments
- 좋은 글이고 거의 모든 내용에 동의한다. LLVM IR은 요즘 실제로 매우 안정적이다. Fil-C를 llvm 17에서 20으로 리베이스하는 데 하루밖에 안 걸렸다.
- LLVM에서 특히 보고 싶은 것은 C가 아닌 LLVM IR에서 시작하는 포괄적인 실행 테스트 스위트다. SelectionDAG에 대한 문서가 많지 않다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
LLVM: Las partes malas
***** TLDR
Un análisis honesto de los puntos débiles de LLVM: no hay suficientes revisores causando mala experiencia para contribuidores, cambios constantes en la API rompiendo proyectos dependientes, tiempos de compilación dolorosamente lentos, CI inestable, pesadillas con valores undef, y migraciones incompletas que se arrastran por años. El autor enmarca esto como 'oportunidades para mejorar' en lugar de defectos fatales.
***** Take
Los compiladores que compilan tus compiladores están sostenidos con cinta adhesiva y la desesperación silenciosa de mantenedores que han visto demasiado. Al menos ahora son honestos al respecto.
***** Comments
- Este es un buen artículo y estoy de acuerdo con casi todo. El IR de LLVM es realmente bastante estable hoy en día. Pude rebasar Fil-C de llvm 17 a 20 en un solo día de trabajo.
- Una de las cosas que especialmente quiero ver construida para LLVM es una suite de pruebas ejecutables completa que comience no desde C sino desde LLVM IR. No hay mucha documentación sobre todo lo de SelectionDAG.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
LLVM: Die schlechten Seiten
***** TLDR
Eine ehrliche Analyse der Schwachstellen von LLVM: zu wenige Reviewer führen zu schlechter Contributor-Erfahrung, ständige API-Änderungen brechen Downstream-Projekte, quälend langsame Build-Zeiten, instabile CI, undef-Alpträume und unvollständige Migrationen, die sich über Jahre hinziehen. Der Autor rahmt dies als 'Verbesserungsmöglichkeiten' statt als fatale Fehler.
***** Take
Die Compiler, die deine Compiler kompilieren, werden von Klebeband und der stillen Verzweiflung von Maintainern zusammengehalten, die zu viel gesehen haben. Wenigstens sind sie jetzt ehrlich.
***** Comments
- Das ist ein guter Artikel und ich stimme fast allem zu. LLVM IR ist heutzutage tatsächlich bemerkenswert stabil. Ich konnte Fil-C in einem einzigen Arbeitstag von llvm 17 auf 20 rebasen.
- Was ich besonders für LLVM aufgebaut sehen möchte, ist eine umfassende ausführbare Testsuite, die nicht von C, sondern von LLVM IR ausgeht. Es gibt nicht viel Dokumentation über das ganze SelectionDAG-Zeug.
** Unauthenticated remote code execution in OpenCode :security:vulnerability:ai:rce:
:PROPERTIES:
:ID:       46581095
:URL:      https://cy.md/opencode-rce/
:HN_URL:   https://news.ycombinator.com/item?id=46581095
:POINTS:   75
:COMMENTS: 12
:BY:       CyberShadow
:END:

*** TLDR
OpenCode, an AI coding assistant, had a nasty vulnerability: it started an unauthenticated web server that let any website or local process execute arbitrary commands on your machine. Reported in Nov 2025, multiple contact attempts went ignored, partial fix in Dec, server disabled by default in Jan 2026. Update to v1.1.10.

*** Take
An AI coding tool that lets random websites run shell commands on your machine. In the security world, we call this 'job creation for incident response teams.'

*** Comments

**** thdxr
:PROPERTIES:
:COMMENT_ID: 46581096
:END:
Hey maintainer here. We've done a poor job handling these security reports, usage has grown rapidly and we're overwhelmed with issues. We're meeting with some people this week to advise us on how to handle this better, get a bug bounty program funded.

**** AlexErrant
:PROPERTIES:
:COMMENT_ID: 46581097
:END:
The disclosure timeline is concerning. Reported 2025-11-17, and multiple 'no responses' after repeated attempts to contact the maintainers... not a good look.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
OpenCode中的未授权远程代码执行漏洞
***** TLDR
AI编程助手OpenCode存在严重漏洞：它启动了一个未授权的Web服务器，允许任何网站或本地进程在你的机器上执行任意命令。2025年11月报告，多次联系尝试被忽略，12月部分修复，2026年1月服务器默认禁用。请更新到v1.1.10。
***** Take
一个让随机网站在你机器上运行shell命令的AI编程工具。在安全领域，我们称之为'为事件响应团队创造就业机会'。
***** Comments
- 维护者在此。我们处理这些安全报告做得很差，使用量增长太快，问题压得我们喘不过气。这周我们正在与一些人会面，商讨如何更好地处理这个问题，并资助一个漏洞赏金计划。
- 披露时间线令人担忧。2025年11月17日报告，多次尝试联系维护者后都没有回应...这不太好看。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
OpenCodeにおける未認証リモートコード実行の脆弱性
***** TLDR
AIコーディングアシスタントOpenCodeに深刻な脆弱性があった：未認証のWebサーバーを起動し、任意のウェブサイトやローカルプロセスがマシン上で任意のコマンドを実行できた。2025年11月に報告、複数の連絡試行が無視され、12月に部分修正、2026年1月にサーバーがデフォルトで無効化。v1.1.10にアップデートを。
***** Take
ランダムなウェブサイトがあなたのマシンでシェルコマンドを実行できるAIコーディングツール。セキュリティ業界では、これを「インシデント対応チームの雇用創出」と呼ぶ。
***** Comments
- メンテナーです。これらのセキュリティレポートの対応がまずかった。利用が急増して課題に圧倒されている。今週、これをより良く処理する方法についてアドバイスをもらい、バグバウンティプログラムに資金を得るために何人かと会う予定。
- 開示のタイムラインが気になる。2025年11月17日に報告され、メンテナーへの複数の連絡試行後も「応答なし」...あまり良い印象ではない。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
OpenCode의 미인증 원격 코드 실행 취약점
***** TLDR
AI 코딩 도우미 OpenCode에 심각한 취약점이 있었다: 미인증 웹 서버를 시작해서 모든 웹사이트나 로컬 프로세스가 당신 컴퓨터에서 임의 명령을 실행할 수 있었다. 2025년 11월 보고, 여러 차례 연락 시도가 무시됨, 12월 부분 수정, 2026년 1월 서버 기본 비활성화. v1.1.10으로 업데이트하라.
***** Take
임의의 웹사이트가 당신 컴퓨터에서 셸 명령을 실행할 수 있게 해주는 AI 코딩 도구. 보안 업계에서는 이를 '사고 대응팀을 위한 일자리 창출'이라고 부른다.
***** Comments
- 메인테이너입니다. 이런 보안 보고서 처리를 잘 못했습니다. 사용량이 급증해서 이슈에 압도당하고 있습니다. 이번 주에 몇 분과 만나서 이걸 더 잘 처리하는 방법을 조언받고 버그 바운티 프로그램 자금을 마련할 예정입니다.
- 공개 타임라인이 우려됩니다. 2025-11-17에 보고되었고, 메인테이너에게 여러 번 연락 시도 후에도 '응답 없음'... 좋은 모습은 아닙니다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Ejecución remota de código sin autenticación en OpenCode
***** TLDR
OpenCode, un asistente de codificación con IA, tenía una vulnerabilidad grave: iniciaba un servidor web sin autenticación que permitía a cualquier sitio web o proceso local ejecutar comandos arbitrarios en tu máquina. Reportado en nov 2025, múltiples intentos de contacto ignorados, parche parcial en dic, servidor deshabilitado por defecto en ene 2026. Actualiza a v1.1.10.
***** Take
Una herramienta de codificación con IA que permite a sitios web aleatorios ejecutar comandos de shell en tu máquina. En el mundo de la seguridad, llamamos a esto 'creación de empleo para equipos de respuesta a incidentes.'
***** Comments
- Hola, mantenedor aquí. Hemos hecho un mal trabajo manejando estos reportes de seguridad, el uso ha crecido rápidamente y estamos abrumados con problemas. Nos reuniremos con algunas personas esta semana para que nos asesoren sobre cómo manejar esto mejor y financiar un programa de recompensas por bugs.
- El cronograma de divulgación es preocupante. Reportado el 2025-11-17, y múltiples 'sin respuesta' después de repetidos intentos de contactar a los mantenedores... no se ve bien.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Unauthentifizierte Remote-Code-Ausführung in OpenCode
***** TLDR
OpenCode, ein KI-Coding-Assistent, hatte eine üble Schwachstelle: Er startete einen unauthentifizierten Webserver, der jeder Website oder lokalen Prozessen erlaubte, beliebige Befehle auf deinem Rechner auszuführen. Nov 2025 gemeldet, mehrere Kontaktversuche ignoriert, teilweise Behebung im Dez, Server im Jan 2026 standardmäßig deaktiviert. Update auf v1.1.10.
***** Take
Ein KI-Coding-Tool, das zufälligen Websites erlaubt, Shell-Befehle auf deinem Rechner auszuführen. In der Sicherheitswelt nennen wir das 'Arbeitsplatzbeschaffung für Incident-Response-Teams.'
***** Comments
- Hey, Maintainer hier. Wir haben diese Sicherheitsmeldungen schlecht gehandhabt, die Nutzung ist schnell gewachsen und wir sind mit Issues überwältigt. Wir treffen uns diese Woche mit einigen Leuten, die uns beraten sollen, wie wir das besser handhaben und ein Bug-Bounty-Programm finanzieren können.
- Die Offenlegungszeitlinie ist besorgniserregend. Am 17.11.2025 gemeldet, und mehrfach 'keine Antwort' nach wiederholten Versuchen, die Maintainer zu kontaktieren... kein guter Eindruck.
** Date is out, Temporal is in :javascript:webdev:api:standards:
:PROPERTIES:
:ID:       46589658
:URL:      https://piccalil.li/blog/date-is-out-and-temporal-is-in/
:HN_URL:   https://news.ycombinator.com/item?id=46589658
:POINTS:   200
:COMMENTS: 71
:BY:       alexanderameye
:END:

*** TLDR
JavaScript's Temporal API is finally landing in browsers. It fixes Date's many sins: no more zero-indexed months, no more mutable date objects, proper timezone support, and date math that actually makes sense. Instead of modifying dates in place, Temporal returns new immutable objects.

*** Take
After 30 years of Date being wrong about everything except the current time, JavaScript finally gets datetime right. Your grandchildren will still be maintaining code that uses Date though.

*** Comments

**** tshaddox
:PROPERTIES:
:COMMENT_ID: 46589659
:END:
This article lists several of the absurdities of the Date constructor. The example: new Date('2026-01-02') gets the day wrong because it parses ISO strings as UTC but displays in local time.

**** LegionMammal978
:PROPERTIES:
:COMMENT_ID: 46589660
:END:
I find it annoying how the Temporal API, just like nearly all other datetime APIs, has 0 support for querying leap-second information in any shape or form. Workarounds require plugging in a leap-second file and keeping it updated.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Date已过时，Temporal来了
***** TLDR
JavaScript的Temporal API终于登陆浏览器。它修复了Date的众多问题：不再有从零开始的月份，不再有可变的日期对象，正确的时区支持，以及真正合理的日期运算。Temporal不是就地修改日期，而是返回新的不可变对象。
***** Take
在Date错了30年之后（除了当前时间），JavaScript终于把日期时间做对了。不过你的孙辈们仍然会维护使用Date的代码。
***** Comments
- 这篇文章列出了Date构造函数的几个荒谬之处。例如：new Date('2026-01-02')会得到错误的日期，因为它将ISO字符串解析为UTC但以本地时间显示。
- 我觉得Temporal API和几乎所有其他日期时间API一样，完全不支持查询闰秒信息，这很烦人。变通方法需要导入闰秒文件并保持更新。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Dateは終わり、Temporalの時代
***** TLDR
JavaScriptのTemporal APIがついにブラウザに登場。Dateの多くの罪を修正：ゼロインデックスの月はもうなし、ミュータブルな日付オブジェクトもなし、適切なタイムゾーンサポート、そして実際に意味のある日付計算。Temporalは日付をその場で変更する代わりに、新しいイミュータブルなオブジェクトを返す。
***** Take
Dateが現在時刻以外のすべてを間違え続けて30年、JavaScriptはついに日時を正しく扱えるようになった。でも孫の代もDateを使ったコードをメンテしているだろう。
***** Comments
- この記事はDateコンストラクタの不合理な点をいくつか挙げている。例：new Date('2026-01-02')は日付を間違える。ISO文字列をUTCとしてパースするがローカルタイムで表示するから。
- Temporal APIも他のほぼすべてのdatetime APIと同様に、閏秒情報のクエリをまったくサポートしていないのが残念。回避策には閏秒ファイルを導入して更新し続ける必要がある。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Date는 끝, Temporal이 왔다
***** TLDR
JavaScript의 Temporal API가 드디어 브라우저에 도착했다. Date의 많은 죄를 수정한다: 0부터 시작하는 월 없음, 변경 가능한 날짜 객체 없음, 적절한 시간대 지원, 실제로 말이 되는 날짜 연산. Temporal은 날짜를 제자리에서 수정하는 대신 새로운 불변 객체를 반환한다.
***** Take
Date가 현재 시간 빼고 모든 걸 틀린 지 30년 만에 JavaScript가 드디어 날짜시간을 제대로 처리한다. 하지만 손주들도 여전히 Date를 사용하는 코드를 유지보수할 것이다.
***** Comments
- 이 기사는 Date 생성자의 여러 불합리한 점을 나열한다. 예: new Date('2026-01-02')는 날짜를 잘못 구한다. ISO 문자열을 UTC로 파싱하지만 로컬 시간으로 표시하기 때문이다.
- Temporal API도 거의 모든 다른 datetime API처럼 윤초 정보 쿼리를 전혀 지원하지 않는 게 짜증난다. 우회 방법은 윤초 파일을 연결하고 계속 업데이트해야 한다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Date está fuera, Temporal ha llegado
***** TLDR
La API Temporal de JavaScript finalmente llega a los navegadores. Corrige los muchos pecados de Date: no más meses indexados desde cero, no más objetos de fecha mutables, soporte de zona horaria apropiado, y matemáticas de fechas que realmente tienen sentido. En lugar de modificar fechas en su lugar, Temporal devuelve nuevos objetos inmutables.
***** Take
Después de 30 años de que Date esté equivocado sobre todo excepto la hora actual, JavaScript finalmente maneja datetime correctamente. Tus nietos seguirán manteniendo código que usa Date, sin embargo.
***** Comments
- Este artículo enumera varias de las absurdidades del constructor Date. El ejemplo: new Date('2026-01-02') obtiene el día incorrecto porque parsea cadenas ISO como UTC pero las muestra en hora local.
- Me resulta molesto cómo la API Temporal, al igual que casi todas las otras APIs de datetime, no tiene soporte para consultar información de segundos intercalares. Los workarounds requieren conectar un archivo de segundos intercalares y mantenerlo actualizado.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Date ist raus, Temporal ist da
***** TLDR
JavaScripts Temporal API landet endlich in Browsern. Es behebt die vielen Sünden von Date: keine nullindizierten Monate mehr, keine veränderlichen Datumsobjekte mehr, ordentliche Zeitzonen-Unterstützung und Datumsrechnung, die tatsächlich Sinn ergibt. Statt Daten an Ort und Stelle zu ändern, gibt Temporal neue unveränderliche Objekte zurück.
***** Take
Nach 30 Jahren, in denen Date alles außer der aktuellen Uhrzeit falsch gemacht hat, kann JavaScript endlich Datetime richtig. Deine Enkel werden aber immer noch Code warten, der Date verwendet.
***** Comments
- Dieser Artikel listet mehrere Absurditäten des Date-Konstruktors auf. Das Beispiel: new Date('2026-01-02') liefert den falschen Tag, weil es ISO-Strings als UTC parst, aber in lokaler Zeit anzeigt.
- Ich finde es ärgerlich, dass die Temporal API, wie fast alle anderen Datetime-APIs, keinerlei Unterstützung für das Abfragen von Schaltsekunden-Informationen hat. Workarounds erfordern das Einbinden einer Schaltsekunden-Datei und deren Aktualisierung.
** Zen-C: Write like a high-level language, run like C :programming-languages:c:compilers:systems:
:PROPERTIES:
:ID:       46587804
:URL:      https://github.com/z-libs/Zen-C
:HN_URL:   https://news.ycombinator.com/item?id=46587804
:POINTS:   128
:COMMENTS: 74
:BY:       simonpure
:END:

*** TLDR
Zen-C is a new language that transpiles to readable GNU C, offering type inference, pattern matching, generics, traits, async/await, and defer. It promises high-level ergonomics with zero overhead and 100% C ABI compatibility. Think Rust's features without leaving the C ecosystem.

*** Take
Another 'C but better' language enters the ring. This one at least compiles to readable C so when it gets abandoned in 2 years, your code is still usable. Smart, actually.

*** Comments

**** Joker_vD
:PROPERTIES:
:COMMENT_ID: 46587805
:END:
From what I can see in the codegen, defer is not implemented 'properly': the deferred statements are only executed when the block exits normally; leaving the block via return, break, continue, or goto skips them entirely.

**** seabrookmx
:PROPERTIES:
:COMMENT_ID: 46587806
:END:
It's odd that the async/await syntax exclusively uses threads under the hood. In every language I've seen the point of async/await is to use an event loop/cooperative multitasking.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Zen-C：像高级语言一样写，像C一样运行
***** TLDR
Zen-C是一种新语言，能转译成可读的GNU C，提供类型推断、模式匹配、泛型、特征、async/await和defer。它承诺高级语言的人体工程学，零开销，100% C ABI兼容。可以理解为不离开C生态的Rust特性。
***** Take
又一个'更好的C'语言加入战局。这个至少能编译成可读的C，所以两年后被弃用时，你的代码还能用。其实挺聪明的。
***** Comments
- 从代码生成来看，defer没有'正确'实现：延迟语句只在块正常退出时执行；通过return、break、continue或goto离开块会完全跳过它们。
- 奇怪的是async/await语法底层只使用线程。在我见过的每种语言中，async/await的要点是使用事件循环/协作式多任务。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Zen-C：高級言語のように書いて、Cのように実行
***** TLDR
Zen-Cは読みやすいGNU Cにトランスパイルする新言語で、型推論、パターンマッチング、ジェネリクス、トレイト、async/await、deferを提供する。高レベルな人間工学とゼロオーバーヘッド、100% C ABI互換を約束する。C エコシステムを離れずにRustの機能を使うイメージ。
***** Take
また一つ「より良いC」言語が参戦。これは少なくとも読めるCにコンパイルされるので、2年後に放棄されてもコードは使える。実は賢い。
***** Comments
- コード生成を見る限り、deferは「正しく」実装されていない：遅延ステートメントはブロックが正常に終了したときのみ実行され、return、break、continue、gotoでブロックを抜けると完全にスキップされる。
- async/await構文が内部で排他的にスレッドを使うのは奇妙だ。私が見たどの言語でも、async/awaitのポイントはイベントループ/協調的マルチタスキングを使うことだ。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Zen-C: 고급 언어처럼 작성하고, C처럼 실행
***** TLDR
Zen-C는 읽기 쉬운 GNU C로 트랜스파일되는 새 언어로, 타입 추론, 패턴 매칭, 제네릭, 트레이트, async/await, defer를 제공한다. 제로 오버헤드와 100% C ABI 호환성으로 고급 언어의 인체공학을 약속한다. C 생태계를 떠나지 않고 Rust의 기능을 쓴다고 생각하면 된다.
***** Take
또 하나의 'C지만 더 나은' 언어가 등장했다. 이건 적어도 읽을 수 있는 C로 컴파일되니까 2년 후 버려져도 코드는 계속 쓸 수 있다. 사실 똑똑하다.
***** Comments
- 코드 생성을 보면 defer가 '제대로' 구현되지 않았다: 지연된 문은 블록이 정상적으로 종료될 때만 실행되고, return, break, continue, goto로 블록을 빠져나가면 완전히 건너뛴다.
- async/await 문법이 내부적으로 스레드만 사용하는 게 이상하다. 내가 본 모든 언어에서 async/await의 핵심은 이벤트 루프/협력적 멀티태스킹을 사용하는 것이다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Zen-C: Escribe como un lenguaje de alto nivel, ejecuta como C
***** TLDR
Zen-C es un nuevo lenguaje que transpila a GNU C legible, ofreciendo inferencia de tipos, pattern matching, generics, traits, async/await y defer. Promete ergonomía de alto nivel con cero overhead y 100% compatibilidad con el ABI de C. Piensa en las características de Rust sin salir del ecosistema C.
***** Take
Otro lenguaje 'C pero mejor' entra al ring. Este al menos compila a C legible, así que cuando sea abandonado en 2 años, tu código seguirá siendo utilizable. Inteligente, en realidad.
***** Comments
- Por lo que puedo ver en el codegen, defer no está implementado 'correctamente': las sentencias diferidas solo se ejecutan cuando el bloque sale normalmente; salir del bloque via return, break, continue o goto las salta completamente.
- Es extraño que la sintaxis async/await use exclusivamente threads por debajo. En todos los lenguajes que he visto, el punto de async/await es usar un event loop/multitarea cooperativa.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Zen-C: Schreibe wie eine Hochsprache, laufe wie C
***** TLDR
Zen-C ist eine neue Sprache, die zu lesbarem GNU C transpiliert und Typinferenz, Pattern Matching, Generics, Traits, async/await und defer bietet. Sie verspricht High-Level-Ergonomie mit null Overhead und 100% C-ABI-Kompatibilität. Denk an Rusts Features, ohne das C-Ökosystem zu verlassen.
***** Take
Eine weitere 'C aber besser'-Sprache betritt den Ring. Diese kompiliert wenigstens zu lesbarem C, also wenn sie in 2 Jahren aufgegeben wird, ist dein Code noch nutzbar. Eigentlich clever.
***** Comments
- Soweit ich im Codegen sehen kann, ist defer nicht 'richtig' implementiert: Die verzögerten Anweisungen werden nur ausgeführt, wenn der Block normal beendet wird; Verlassen des Blocks via return, break, continue oder goto überspringt sie komplett.
- Es ist seltsam, dass die async/await-Syntax ausschließlich Threads unter der Haube verwendet. In jeder Sprache, die ich gesehen habe, ist der Punkt von async/await die Verwendung einer Event Loop/kooperatives Multitasking.